<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Node.js Metrics Dashboard</title>
  <style>
    :root {
      --color-primary: #4f46e5;
      --color-secondary: #7c3aed;
      --color-success: #10b981;
      --color-warning: #f59e0b;
      --color-danger: #ef4444;
      --color-background: #f9fafb;
      --color-card: #ffffff;
      --color-text: #1f2937;
      --color-text-light: #6b7280;
      --color-border: #e5e7eb;
      --border-radius: 12px;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }

    body {
      background-color: var(--color-background);
      color: var(--color-text);
      min-height: 100vh;
      padding: 1.5rem;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    header {
      margin-bottom: 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .header-left h1 {
      font-size: 2.25rem;
      margin-bottom: 0.5rem;
      background: linear-gradient(90deg, var(--color-primary), var(--color-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-fill-color: transparent;
    }

    .header-left .subtitle {
      color: var(--color-text-light);
      font-size: 1.1rem;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .refresh-button {
      background-color: var(--color-primary);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s ease;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .refresh-button:hover {
      background-color: var(--color-secondary);
    }

    .refresh-icon {
      width: 16px;
      height: 16px;
      animation: spin 1s linear infinite;
      display: none;
    }

    .refreshing .refresh-icon {
      display: inline-block;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .status-overview {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .status-card {
      background-color: var(--color-card);
      border-radius: var(--border-radius);
      padding: 1.5rem;
      box-shadow: var(--shadow);
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: column;
    }

    .status-card:hover {
      transform: translateY(-5px);
    }

    .status-card h2 {
      font-size: 1.1rem;
      margin-bottom: 1rem;
      color: var(--color-text-light);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-card .value {
      font-size: 2rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }

    .status-card .description {
      color: var(--color-text-light);
      font-size: 0.9rem;
      margin-top: auto;
    }

    .status-card.healthy .value {
      color: var(--color-success);
    }

    .status-card.warning .value {
      color: var(--color-warning);
    }

    .status-card.critical .value {
      color: var(--color-danger);
    }

    .metrics-section {
      margin-bottom: 2.5rem;
    }

    .metrics-section h2 {
      font-size: 1.5rem;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--color-border);
    }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.5rem;
    }

    .metric-card {
      background-color: var(--color-card);
      border-radius: var(--border-radius);
      padding: 1.5rem;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
    }

    .metric-card:hover {
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    .metric-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .metric-name {
      font-size: 1.1rem;
      font-weight: 600;
    }

    .metric-value {
      font-size: 1.5rem;
      font-weight: bold;
      margin: 0.5rem 0;
    }

    .metric-details {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--color-border);
    }

    .detail-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
    }

    .detail-label {
      color: var(--color-text-light);
    }

    .detail-value {
      font-weight: 500;
    }

    .progress-bar {
      height: 8px;
      background-color: #e5e7eb;
      border-radius: 4px;
      margin: 0.5rem 0 1rem 0;
      overflow: hidden;
    }

    .progress-value {
      height: 100%;
      border-radius: 4px;
      background: linear-gradient(90deg, var(--color-primary), var(--color-secondary));
      transition: width 0.3s ease;
    }

    .progress-value.warning {
      background: linear-gradient(90deg, var(--color-warning), #fdba74);
    }

    .progress-value.danger {
      background: linear-gradient(90deg, var(--color-danger), #fca5a5);
    }

    .progress-value.success {
      background: linear-gradient(90deg, var(--color-success), #6ee7b7);
    }

    .last-updated {
      text-align: center;
      margin-top: 2rem;
      color: var(--color-text-light);
      font-size: 0.9rem;
    }

    .chart-container {
      width: 100%;
      height: 200px;
      margin: 1rem 0;
    }

    .table-container {
      overflow-x: auto;
      margin: 1rem 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th, td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid var(--color-border);
    }

    th {
      font-weight: 600;
      color: var(--color-text-light);
    }

    tr:last-child td {
      border-bottom: none;
    }

    .badge {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .badge-success {
      background-color: rgba(16, 185, 129, 0.1);
      color: var(--color-success);
    }

    .badge-warning {
      background-color: rgba(245, 158, 11, 0.1);
      color: var(--color-warning);
    }

    .badge-danger {
      background-color: rgba(239, 68, 68, 0.1);
      color: var(--color-danger);
    }

    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }
      
      .header-left h1 {
        font-size: 1.75rem;
      }
      
      .status-overview {
        grid-template-columns: 1fr;
      }
      
      .metrics-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="header-left">
        <h1>Node.js Metrics Dashboard</h1>
        <p class="subtitle">Real-time performance monitoring</p>
      </div>
      <div class="header-right">
        <button id="refresh-button" class="refresh-button">
          <svg class="refresh-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
          Refresh Metrics
        </button>
      </div>
    </header>

    <div class="status-overview">
      <div class="status-card" id="cpu-card">
        <h2>
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect>
            <rect x="9" y="9" width="6" height="6"></rect>
            <line x1="9" y1="1" x2="9" y2="4"></line>
            <line x1="15" y1="1" x2="15" y2="4"></line>
            <line x1="9" y1="20" x2="9" y2="23"></line>
            <line x1="15" y1="20" x2="15" y2="23"></line>
            <line x1="20" y1="9" x2="23" y2="9"></line>
            <line x1="20" y1="14" x2="23" y2="14"></line>
            <line x1="1" y1="9" x2="4" y2="9"></line>
            <line x1="1" y1="14" x2="4" y2="14"></line>
          </svg>
          CPU Usage
        </h2>
        <div class="value" id="cpu-value">0.00s</div>
        <div class="progress-bar">
          <div class="progress-value" id="cpu-progress" style="width: 0%"></div>
        </div>
        <div class="description">Total CPU time spent (user + system)</div>
      </div>

      <div class="status-card" id="memory-card">
        <h2>
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M6 19v-3"></path>
            <path d="M10 19v-3"></path>
            <path d="M14 19v-3"></path>
            <path d="M18 19v-3"></path>
            <path d="M3 7c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z"></path>
            <path d="M10 5V3"></path>
            <path d="M14 5V3"></path>
          </svg>
          Memory Usage
        </h2>
        <div class="value" id="memory-value">0 MB</div>
        <div class="progress-bar">
          <div class="progress-value" id="memory-progress" style="width: 0%"></div>
        </div>
        <div class="description">Resident memory in use</div>
      </div>

      <div class="status-card" id="eventloop-card">
        <h2>
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"></circle>
            <polyline points="12 6 12 12 16 14"></polyline>
          </svg>
          Event Loop Lag
        </h2>
        <div class="value" id="eventloop-value">0.00ms</div>
        <div class="progress-bar">
          <div class="progress-value success" id="eventloop-progress" style="width: 0%"></div>
        </div>
        <div class="description">Current event loop lag</div>
      </div>

      <div class="status-card" id="heap-card">
        <h2>
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
            <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
            <line x1="12" y1="22.08" x2="12" y2="12"></line>
          </svg>
          Heap Usage
        </h2>
        <div class="value" id="heap-value">0 MB</div>
        <div class="progress-bar">
          <div class="progress-value" id="heap-progress" style="width: 0%"></div>
        </div>
        <div class="description">Node.js heap memory used</div>
      </div>
    </div>

    <div class="metrics-section">
      <h2>Node.js Runtime</h2>
      <div class="metrics-grid">
        <div class="metric-card">
          <div class="metric-header">
            <div class="metric-name">Node.js Version</div>
          </div>
          <div class="metric-value" id="nodejs-version">v0.0.0</div>
          <div class="metric-details">
            <div class="detail-item">
              <span class="detail-label">Process Start Time</span>
              <span class="detail-value" id="process-start-time">-</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Uptime</span>
              <span class="detail-value" id="process-uptime">-</span>
            </div>
          </div>
        </div>

        <div class="metric-card">
          <div class="metric-header">
            <div class="metric-name">Active Resources</div>
          </div>
          <div class="metric-value" id="active-resources-total">0</div>
          <div class="table-container">
            <table id="active-resources-table">
              <thead>Memory Details

                <tr>
                  <th>Type</th>
                  <th>Count</th>
                </tr>
              </thead>
              <tbody>
                <!-- Will be populated by JavaScript -->
              </tbody>
            </table>
          </div>
        </div>

        <div class="metric-card">
          <div class="metric-header">
            <div class="metric-name">Active Handles</div>
          </div>
          <div class="metric-value" id="active-handles-total">0</div>
          <div class="table-container">
            <table id="active-handles-table">
              <thead>
                <tr>
                  <th>Type</th>
                  <th>Count</th>
                </tr>
              </thead>
              <tbody>
                <!-- Will be populated by JavaScript -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="metrics-section">
      <h2>Memory Details</h2>
      <div class="metrics-grid">
        <div class="metric-card">
          <div class="metric-header">
            <div class="metric-name">Heap Spaces</div>
          </div>
          <div class="table-container">
            <table id="heap-spaces-table">
              <thead>
                <tr>
                  <th>Space</th>
                  <th>Used</th>
                  <th>Total</th>
                  <th>%</th>
                </tr>
              </thead>
              <tbody>
                <!-- Will be populated by JavaScript -->
              </tbody>
            </table>
          </div>
        </div>

        <div class="metric-card">
          <div class="metric-header">
            <div class="metric-name">Garbage Collection</div>
          </div>
          <div class="table-container">
            <table id="gc-table">
              <thead>
                <tr>
                  <th>Type</th>
                  <th>Count</th>
                  <th>Duration</th>
                </tr>
              </thead>
              <tbody>
                <!-- Will be populated by JavaScript -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="metrics-section">
      <h2>HTTP Requests</h2>
      <div class="metrics-grid">
        <div class="metric-card">
          <div class="metric-header">
            <div class="metric-name">Request Duration</div>
          </div>
          <div class="table-container">
            <table id="http-requests-table">
              <thead>
                <tr>
                  <th>Method</th>
                  <th>Route</th>
                  <th>Status</th>
                  <th>Duration</th>
                  <th>Count</th>
                </tr>
              </thead>
              <tbody>
                <!-- Will be populated by JavaScript -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="last-updated">
      Last updated: <span id="timestamp">-</span>
    </div>
  </div>

  <script>
    // Helper functions
    function formatBytes(bytes, decimals = 2) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    function formatDuration(seconds) {
      if (seconds < 0.001) {
        return (seconds * 1000000).toFixed(2) + 'μs';
      } else if (seconds < 1) {
        return (seconds * 1000).toFixed(2) + 'ms';
      } else {
        return seconds.toFixed(2) + 's';
      }
    }

    function formatDate(timestamp) {
      const date = new Date(timestamp * 1000);
      return date.toLocaleString();
    }

    function formatUptime(startTime) {
      const uptime = Math.floor(Date.now() / 1000) - startTime;
      const days = Math.floor(uptime / 86400);
      const hours = Math.floor((uptime % 86400) / 3600);
      const minutes = Math.floor((uptime % 3600) / 60);
      const seconds = uptime % 60;
      
      if (days > 0) {
        return `${days}d ${hours}h ${minutes}m ${seconds}s`;
      } else if (hours > 0) {
        return `${hours}h ${minutes}m ${seconds}s`;
      } else if (minutes > 0) {
        return `${minutes}m ${seconds}s`;
      } else {
        return `${seconds}s`;
      }
    }

    // Parse Prometheus metrics
    function parsePrometheusMetrics(text) {
      const metrics = {};
      const lines = text.split('\n');
      let currentMetric = null;
      
      for (const line of lines) {
        if (line.startsWith('# HELP')) {
          const parts = line.split(' ');
          const name = parts[2];
          const help = parts.slice(3).join(' ');
          metrics[name] = { name, help, type: null, values: [] };
          currentMetric = name;
        } else if (line.startsWith('# TYPE')) {
          const parts = line.split(' ');
          const name = parts[2];
          const type = parts[3];
          if (metrics[name]) {
            metrics[name].type = type;
          }
        } else if (line.trim() && !line.startsWith('#')) {
          const valueMatch = line.match(/^([a-zA-Z0-9_]+)(?:{([^}]*)})?(?:\s+(.+))?$/);
          if (valueMatch) {
            const name = valueMatch[1];
            const labels = valueMatch[2] ? parseLabels(valueMatch[2]) : {};
            const value = valueMatch[3] ? parseFloat(valueMatch[3]) : null;
            
            if (!metrics[name]) {
              metrics[name] = { name, help: '', type: null, values: [] };
            }
            
            metrics[name].values.push({ labels, value });
          }
        }
      }
      
      return metrics;
    }

    function parseLabels(labelsStr) {
      const labels = {};
      const labelPairs = labelsStr.split(',');
      
      for (const pair of labelPairs) {
        const [key, value] = pair.split('=');
        if (key && value) {
          labels[key.trim()] = value.trim().replace(/^"(.*)"$/, '$1');
        }
      }
      
      return labels;
    }

    // Update UI with metrics
    function updateUI(metrics) {
      // Update timestamp
      document.getElementById('timestamp').textContent = new Date().toLocaleString();
      
      // CPU metrics
      const cpuTotal = metrics['process_cpu_seconds_total']?.values[0]?.value || 0;
      document.getElementById('cpu-value').textContent = formatDuration(cpuTotal);
      document.getElementById('cpu-progress').style.width = `${Math.min(cpuTotal * 5, 100)}%`;
      
      // Memory metrics
      const memoryBytes = metrics['process_resident_memory_bytes']?.values[0]?.value || 0;
      document.getElementById('memory-value').textContent = formatBytes(memoryBytes);
      
      const totalHeapSize = metrics['nodejs_heap_size_total_bytes']?.values[0]?.value || 1;
      const memoryPercentage = (memoryBytes / (totalHeapSize * 2)) * 100;
      document.getElementById('memory-progress').style.width = `${Math.min(memoryPercentage, 100)}%`;
      
      // Event loop lag
      const eventLoopLag = metrics['nodejs_eventloop_lag_seconds']?.values[0]?.value || 0;
      document.getElementById('eventloop-value').textContent = formatDuration(eventLoopLag);
      
      const lagPercentage = (eventLoopLag / 0.1) * 100; // 100ms is considered high
      document.getElementById('eventloop-progress').style.width = `${Math.min(lagPercentage, 100)}%`;
      
      if (lagPercentage > 80) {
        document.getElementById('eventloop-progress').className = 'progress-value danger';
      } else if (lagPercentage > 50) {
        document.getElementById('eventloop-progress').className = 'progress-value warning';
      } else {
        document.getElementById('eventloop-progress').className = 'progress-value success';
      }
      
      // Heap usage
      const heapUsed = metrics['nodejs_heap_size_used_bytes']?.values[0]?.value || 0;
      const heapTotal = metrics['nodejs_heap_size_total_bytes']?.values[0]?.value || 1;
      document.getElementById('heap-value').textContent = formatBytes(heapUsed);
      
      const heapPercentage = (heapUsed / heapTotal) * 100;
      document.getElementById('heap-progress').style.width = `${heapPercentage}%`;
      
      if (heapPercentage > 80) {
        document.getElementById('heap-progress').className = 'progress-value danger';
      } else if (heapPercentage > 60) {
        document.getElementById('heap-progress').className = 'progress-value warning';
      } else {
        document.getElementById('heap-progress').className = 'progress-value success';
      }
      
      // Node.js version
      const versionInfo = metrics['nodejs_version_info']?.values[0];
      if (versionInfo) {
        document.getElementById('nodejs-version').textContent = `v${versionInfo.labels.version}`;
      }
      
      // Process start time
      const startTime = metrics['process_start_time_seconds']?.values[0]?.value;
      if (startTime) {
        document.getElementById('process-start-time').textContent = formatDate(startTime);
        document.getElementById('process-uptime').textContent = formatUptime(startTime);
      }
      
      // Active resources
      const activeResourcesTotal = metrics['nodejs_active_resources_total']?.values[0]?.value || 0;
      document.getElementById('active-resources-total').textContent = activeResourcesTotal;
      
      const activeResourcesTable = document.getElementById('active-resources-table').querySelector('tbody');
      activeResourcesTable.innerHTML = '';
      
      const activeResources = metrics['nodejs_active_resources']?.values || [];
      for (const resource of activeResources) {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${resource.labels.type}</td>
          <td>${resource.value}</td>
        `;
        activeResourcesTable.appendChild(row);
      }
      
      // Active handles
      const activeHandlesTotal = metrics['nodejs_active_handles_total']?.values[0]?.value || 0;
      document.getElementById('active-handles-total').textContent = activeHandlesTotal;
      
      const activeHandlesTable = document.getElementById('active-handles-table').querySelector('tbody');
      activeHandlesTable.innerHTML = '';
      
      const activeHandles = metrics['nodejs_active_handles']?.values || [];
      for (const handle of activeHandles) {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${handle.labels.type}</td>
          <td>${handle.value}</td>
        `;
        activeHandlesTable.appendChild(row);
      }
      
      // Heap spaces
      const heapSpacesTable = document.getElementById('heap-spaces-table').querySelector('tbody');
      heapSpacesTable.innerHTML = '';
      
      const heapSpacesTotal = metrics['nodejs_heap_space_size_total_bytes']?.values || [];
      const heapSpacesUsed = metrics['nodejs_heap_space_size_used_bytes']?.values || [];
      
      const heapSpaces = {};
      for (const space of heapSpacesTotal) {
        const spaceName = space.labels.space;
        heapSpaces[spaceName] = { name: spaceName, total: space.value, used: 0 };
      }
      
      for (const space of heapSpacesUsed) {
        const spaceName = space.labels.space;
        if (heapSpaces[spaceName]) {
          heapSpaces[spaceName].used = space.value;
        }
      }
      
      for (const spaceName in heapSpaces) {
        const space = heapSpaces[spaceName];
        const percentage = (space.used / space.total) * 100;
        
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${space.name}</td>
          <td>${formatBytes(space.used)}</td>
          <td>${formatBytes(space.total)}</td>
          <td>${percentage.toFixed(1)}%</td>
        `;
        heapSpacesTable.appendChild(row);
      }
      
      // Garbage collection
      const gcTable = document.getElementById('gc-table').querySelector('tbody');
      gcTable.innerHTML = '';
      
      const gcDurations = metrics['nodejs_gc_duration_seconds_sum']?.values || [];
      const gcCounts = metrics['nodejs_gc_duration_seconds_count']?.values || [];
      
      const gcMetrics = {};
      for (const gc of gcDurations) {
        const kind = gc.labels.kind;
        gcMetrics[kind] = { kind, duration: gc.value, count: 0 };
      }
      
      for (const gc of gcCounts) {
        const kind = gc.labels.kind;
        if (gcMetrics[kind]) {
          gcMetrics[kind].count = gc.value;
        }
      }
      
      for (const kind in gcMetrics) {
        const gc = gcMetrics[kind];
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${gc.kind}</td>
          <td>${gc.count}</td>
          <td>${formatDuration(gc.duration)}</td>
        `;
        gcTable.appendChild(row);
      }
      
      // HTTP requests
      const httpTable = document.getElementById('http-requests-table').querySelector('tbody');
      httpTable.innerHTML = '';
      
      const httpDurations = metrics['http_request_duration_seconds_sum']?.values || [];
      const httpCounts = metrics['http_request_duration_seconds_count']?.values || [];
      
      const httpMetrics = {};
      for (const http of httpDurations) {
        const key = `${http.labels.method}-${http.labels.route}-${http.labels.status_code}`;
        httpMetrics[key] = { 
          method: http.labels.method, 
          route: http.labels.route, 
          status: http.labels.status_code,
          duration: http.value, 
          count: 0 
        };
      }
      
      for (const http of httpCounts) {
        const key = `${http.labels.method}-${http.labels.route}-${http.labels.status_code}`;
        if (httpMetrics[key]) {
          httpMetrics[key].count = http.value;
        }
      }
      
      for (const key in httpMetrics) {
        const http = httpMetrics[key];
        const avgDuration = http.count > 0 ? http.duration / http.count : 0;
        
        let statusClass = 'badge-success';
        if (http.status >= 400 && http.status < 500) {
          statusClass = 'badge-warning';
        } else if (http.status >= 500) {
          statusClass = 'badge-danger';
        }
        
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${http.method}</td>
          <td>${http.route}</td>
          <td><span class="badge ${statusClass}">${http.status}</span></td>
          <td>${formatDuration(avgDuration)}</td>
          <td>${http.count}</td>
        `;
        httpTable.appendChild(row);
      }
    }

    // Fetch metrics from the server
    async function fetchMetrics() {
      try {
        const refreshButton = document.getElementById('refresh-button');
        refreshButton.classList.add('refreshing');
        
        const response = await fetch('/metrics');
        const text = await response.text();
        const metrics = parsePrometheusMetrics(text);
        
        updateUI(metrics);
        
        refreshButton.classList.remove('refreshing');
      } catch (error) {
        console.error('Error fetching metrics:', error);
        document.getElementById('refresh-button').classList.remove('refreshing');
      }
    }

    // Initial fetch
    fetchMetrics();

    // Set up refresh button
    document.getElementById('refresh-button').addEventListener('click', fetchMetrics);

    // Auto refresh every 30 seconds
    setInterval(fetchMetrics, 30000);
  </script>
</body>
</html>